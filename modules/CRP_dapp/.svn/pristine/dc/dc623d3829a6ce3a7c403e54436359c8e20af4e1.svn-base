const fs = require('fs'); // file-system
const path = require('path'); // path-package
/* 파라메터 체크 */
console.log('* param1 (provider):.......' + process.argv[2]);
console.log('* param2 (web3 path):......' + process.argv[3]);
console.log('* param3 (owner account):..' + process.argv[4]);
console.log('* param4 (owner password):.' + process.argv[5]);
console.log('* param5 (main contract):..' + process.argv[6]);
const provider = process.argv[2];
const owner = process.argv[4];
const passwd = process.argv[5];
const main_address = process.argv[6];
let web3_path = (process.argv[3] == 'null') ? ('web3') : (process.argv[3]);
/* web3 provider 설정 */
const Web3 = require(web3_path); // web3 api
let web3 = new Web3();
web3.setProvider(new web3.providers.HttpProvider(provider)); // set provider
/* deploy에 필요한 요소들 추출 (abi, data, gas) */

let abi_path = path.resolve(__dirname, 'abi', 'CrpMain.abi'); // abi가 저장된 file path
let data_path = path.resolve(__dirname, 'data', 'CrpMain.data'); // data를 저장할 file path
let abi = fs.readFileSync(abi_path, 'utf-8'); // abi 추출
let Main = web3.eth.contract(JSON.parse(abi)); // get contract
let contract = Main.at(main_address);
let data = fs.readFileSync(data_path, 'utf-8'); // bytecode 추출


/**
 * 지정된 시간(ms)만큼 대기한다.  
 *
 * @param _ms 지정한 시간 (ms)
 * @return promise object
 * @author jhhong
 */
function milisleep(_ms) {
    return new Promise(resolve => setTimeout(resolve, _ms));
}

/** 
 * @author sykang
 */
let halt_staff_poll = async () => {
    try {
        await milisleep(1000);
        await web3.personal.unlockAccount(owner, passwd); // Unlock Account
        // let main_addr = await web3.eth.getMainContractAddress(owner);
        // if(main_addr == '0x0000000000000000000000000000000000000000') {
        //     throw new Error('The main contact created by [' + owner + '] does not exist.!');
        // }
        // let contract = Main.at(main_address);
        let receipt; // receipt object를 받을 변수
        let tx;
        let gas = web3.eth.estimateGas({
            data: data
        }); // gas값 계산

        tx = await contract.pollHalt({
            from: owner,
        }); // Main Deploy를 위한 tx 생성
        console.log('TX Hash=[' + tx + ']');
        do {
            receipt = await web3.eth.getTransactionReceipt(tx); // receipt 확인
            if (receipt) {
                console.log("Tx included! BlockHash=[" + receipt.blockHash + "]");
                console.log("Tx included! BlockNumber=[" + receipt.blockNumber + "]");
                break;
            }
            console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
            await milisleep(4000); // 4초 대기
        } while (!receipt);

        let result_bool = await contract.stage({
            from: owner
        }).toNumber();
        if (result_bool == 2) {
            let token_info = await contract.getTokenPrams({
                from: owner
            });

            console.log('------ deploy token contract -----');
            abi_path = path.resolve(__dirname, 'abi', 'CrpToken.abi'); // abi가 저장된 file path
            data_path = path.resolve(__dirname, 'data', 'CrpToken.data'); // data를 저장할 file path
            abi = fs.readFileSync(abi_path, 'utf-8'); // abi 추출
            let token = web3.eth.contract(JSON.parse(abi));
            data = fs.readFileSync(data_path, 'utf-8'); // bytecode 추출

            let data_with_params = token.new.getData(token_info[0], token_info[1], token_info[2], main_address, {
                data: data
            });
            gas = web3.eth.estimateGas({
                data: data_with_params
            });
            let token_contract = await token.new(token_info[0], token_info[1], token_info[2], main_address, {
                from: owner,
                data: data,
                gas: gas,
                mca: main_address
            })
            console.log('TX Hash=[' + token_contract.transactionHash + ']');
            do {
                receipt = await web3.eth.getTransactionReceipt(token_contract.transactionHash); // receipt 확인
                if (receipt) {
                    console.log("Tx included! CA=[" + receipt.contractAddress + "]");
                    break;
                }
                console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
                await milisleep(4000); // 4초 대기
            } while (!receipt);

            console.log('------ regist token contract -----');
            let regist_token = await contract.setTokenContract(receipt.contractAddress, {
                from: owner,
            });
            console.log('TX Hash=[' + regist_token + ']');
            do {
                receipt = await web3.eth.getTransactionReceipt(regist_token); // receipt 확인
                if (receipt) {
                    console.log("Tx included! BlockHash=[" + receipt.blockHash + "]");
                    console.log("Tx included! BlockNumber=[" + receipt.blockNumber + "]");
                    break;
                }
                console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
                await milisleep(4000); // 4초 대기
            } while (!receipt);

            console.log('------ deploy fund contract -----');
            abi_path = path.resolve(__dirname, 'abi', 'CrpFund.abi'); // abi가 저장된 file path
            data_path = path.resolve(__dirname, 'data', 'CrpFund.data'); // data를 저장할 file path
            abi = fs.readFileSync(abi_path, 'utf-8'); // abi 추출
            let Fund = web3.eth.contract(JSON.parse(abi)); // get contract
            data = fs.readFileSync(data_path, 'utf-8'); // bytecode 추출

            data_with_params = Fund.new.getData(main_address, {
                data: data
            });
            gas = web3.eth.estimateGas({
                data: data_with_params
            });

            let fund_contract = await Fund.new(main_address, {
                data: data,
                from: owner,
                gas: gas,
                mca: main_address
            }); // Fund Deploy를 위한 tx 생성
            console.log('TX Hash=[' + fund_contract.transactionHash + ']');
            do {
                receipt = await web3.eth.getTransactionReceipt(fund_contract.transactionHash); // receipt 확인
                if (receipt) {
                    console.log("Tx included! CA=[" + receipt.contractAddress + "]");
                    break;
                }
                console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
                await milisleep(4000); // 4초 대기
            } while (!receipt);

            console.log('------ regist fund contract -----');
            let regist_fund = await contract.setFundContract(receipt.contractAddress, {
                from: owner,
            });
            console.log('TX Hash=[' + regist_fund + ']');
            do {
                receipt = await web3.eth.getTransactionReceipt(regist_fund); // receipt 확인
                if (receipt) {
                    console.log("Tx included! BlockHash=[" + receipt.blockHash + "]");
                    console.log("Tx included! BlockNumber=[" + receipt.blockNumber + "]");
                    break;
                }
                console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
                await milisleep(4000); // 4초 대기
            } while (!receipt);

            console.log('------ deploy sale contract -----');
            abi_path = path.resolve(__dirname, 'abi', 'CrpSaleMain.abi'); // abi가 저장된 file path
            data_path = path.resolve(__dirname, 'data', 'CrpSaleMain.data'); // data를 저장할 file path
            abi = fs.readFileSync(abi_path, 'utf-8'); // abi 추출
            let sale = web3.eth.contract(JSON.parse(abi)); // get contract
            data = fs.readFileSync(data_path, 'utf-8'); // bytecode 추출


            let sale_info = await contract.getSaleMainParams({
                from: owner
            });
            data_with_param = sale.new.getData(sale_info[0], sale_info[1], sale_info[2], sale_info[3],
                sale_info[4], sale_info[5], sale_info[6], sale_info[7], sale_info[8], sale_info[9], {
                    data: data
                });
            gas = web3.eth.estimateGas({
                data: data_with_param
            }); // gas값 계산
            let sale_contract = await sale.new(sale_info[0], sale_info[1], sale_info[2], sale_info[3],
                sale_info[4], sale_info[5], sale_info[6], sale_info[7], sale_info[8], sale_info[9], main_address, {
                    from: owner,
                    data: data,
                    gas: gas,
                    mca: main_address
                }); // Sale Deploy를 위한 tx 생성
            console.log('TX Hash=[' + sale_contract.transactionHash + ']');
            do {
                receipt = await web3.eth.getTransactionReceipt(sale_contract.transactionHash); // receipt 확인
                if (receipt) {
                    console.log("Tx included! CA=[" + receipt.contractAddress + "]");
                    break;
                }
                console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
                await milisleep(4000); // 4초 대기
            } while (!receipt);

            console.log('------ regist sale contract -----');
            let regist_sale = await contract.setCrowdSaleContract(receipt.contractAddress, {
                from: owner,
            });
            console.log('TX Hash=[' + regist_sale + ']');
            do {
                receipt = await web3.eth.getTransactionReceipt(regist_sale); // receipt 확인
                if (receipt) {
                    console.log("Tx included! BlockHash=[" + receipt.blockHash + "]");
                    console.log("Tx included! BlockNumber=[" + receipt.blockNumber + "]");
                    break;
                }
                console.log("Wait for including Tx... Block=[" + web3.eth.blockNumber + "]");
                await milisleep(4000); // 4초 대기
            } while (!receipt);
        } else {
            throw new Error('please question to amdin!!!1');
        }
        await web3.personal.lockAccount(owner); // Lock Account
    } catch (err) {
        console.log(err);
    }
}
halt_staff_poll();